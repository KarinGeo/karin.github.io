[{"content":"一、单例模式 保证一个类只有一个实例，并且提供全局访问点。\n二、单例模式实现原理 1、饿汉式单例 先来看一个Unity中非Mono类的单例模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Sigleton { //静态只读字段 private static readonly Singleton _instance = new Singleton(); //全局访问点 public static Singleton Instance =\u0026gt; _instance; //私有化构造函数 private Singleton() { } } 首先，通过对构造函数私有化。\n然后，使用静态只读字段_instance创建并存储唯一实例。\n最后，使用静态字段Instance访问全局唯一实例中的方法和对象。\n要点解析：\n1、构造函数设为private，杜绝了外部创建实例。\n2、_instance设为static，提供了全局访问。\n3、_instance设为readonly，限制了字段能在定义时或构造函数中进行赋值，之后无法修改它。与static结合使用，就杜绝了在单例类内部创建实例的可能。\n这是C#与公共语言运行库提供的一种”静态初始化“方法，这种方法不需要开发人员显示地编写线程安全代码。\n这也是俗称的”饿汉式“单例。\n2、懒汉式单例 2.1线程不安全懒汉式单例 下面看”懒汉式“单例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Singleton { private static Singleton _instance; private Singleton() { } public static Singleton Instance { get { if (_instance == null) { _instance = new Singleton(); } return _instance; } } } ”懒汉式“单例，是在第一次访问该类时才创建，相比一开始就创建的”饿汉式“单例，可以节省资源。\n2.2线程安全（双重锁定）懒汉式单例 但是，因为多线程的情况下，可能会有多个线程同时进入创建实例的逻辑，导致全局不唯一。\n所以在使用”懒汉式“单例时，应当使用线程安全的单例模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Singleton { private static Singleton _instance; private static readonly object _lock = new object(); private Singleton() { } public static Singleton Instance { get { if (_instance == null) { lock (_lock) { if (_instance == null) { _instance = new Singleton(); } } } return _instance; } } } 其中，lock时确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待，直到该对象被释放。\nQ\u0026amp;A\nQ：为什么不直接锁_instance\nA：因为_instance不一定被创建\nQ：要在lock (_lock)外进行一次存在检查\nA：每次都lock太耗费性能\n3、最优雅的单例模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Singleton { public static Singleton Instance =\u0026gt; Nested.instance; private Singleton() { } private class Nested { static Nested() { } internal static readonly Singleton instance = new Singleton(); } } 利用了 .NET 对静态构造函数的线程安全保证。通过一个辅助类来创建实例，可以获得懒汉式延迟初始化的优势，还没有显示的锁定机制，减少了代码的复杂性和性能开销。\n三、Unity（MonoBehaviour）单例模式 继承于MonoBehaviour的类，因为其生命周期是由 Unity 管理的，不能直接使用静态构造函数或静态字段来实现单例。并且场景中的单例类可能来自于手动挂载和代码添加，不同的访问方式会造成不同的问题。再加上MonoBehaviour的生命周期以及单例类之间的耦合，所以其实并不推荐使用继承于MonoBehaviour的单例模式。\n但是，看的这么多视频、教程里，他实现个单例，他教程做完了啥事没有，我在别的教程里看了个新的好用的结构一用，就能在单例这出毛病。\n继承于MonoBehaviour的单例模式需要手动管理。\n下面是常见的两种写法，一种饿汉式，一种懒汉式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Singleton : MonoBehaviour { private static Singleton _instance;; public static Singleton Instance =\u0026gt; _instance; protected virtual void Awake() { if (_instance) { Destroy(gameObject); } else { _instance = this as Singleton; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Singleton : MonoBehaviour { private static Singleton _instance; public static Singleton Instance { get { if (_instance == null) { _instance = FindObjectOfType\u0026lt;Singleton\u0026gt;(); if (_instance == null) { GameObject obj = new GameObject(typeof(Singleton).Name); _instance = obj.AddComponent\u0026lt;Singleton\u0026gt;(); DontDestroyOnLoad(obj); } } return _instance; } } } 下面是我在使用中遇到的问题：\n1、“饿汉式”需要手动管理，在场景中初始挂载多个时，是否使用Destroy也是问题，为维持单例模式需要删除该物体，但是这样做又可能会删错东西。\n2、“饿汉式”当场景中已经挂载XXXMnager（一个）时，再在其他类中的Awake()里用代码添加XXXMnager（一个）时，XXXMnager的Awake()会执行两次。但场景中只会剩下一个带XXXMnager的物体。\n3、“懒汉式”如果场景种已经挂载多个，“懒汉式”无法删除到只剩一个，因为get{}里无法使用gameObject。\n4、“懒汉式”如果单例A的Awake()里添加了某些组件，单例B访问单例A时，才AddComponent创建A，根本访问不到A的Awake()里添加的组件。\n总结：尽量别用。用也要遵循一些规律，如饿汉式别用代码添加，懒汉式别直接挂载，保持一致性。跟生命周期相关的地方要注意。\n","date":"2025-03-07T16:03:26+08:00","permalink":"https://KarinGeo.github.io/karin.github.io/p/unity%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fsingleton/","title":"【Unity】单例模式Singleton"},{"content":"一、Hugo命令 1、创建新的文件夹\n1 hugo new site xxx 2、创建新的内容（文章）\n1 hugo new content post/xxx/index.md 3、运行服务\n1 2 hugo server --buildDrafts hugo server -D 4、生成github用的文件\n1 hugo -D ","date":"2025-03-07T13:15:49+08:00","permalink":"https://KarinGeo.github.io/karin.github.io/p/common%E5%90%84%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/","title":"【Common】各软件环境的常用命令列表"}]